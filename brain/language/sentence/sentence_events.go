
/*
 * generated by event_generator
 *
 * DO NOT EDIT
 */

package sentence

import "github.com/joernweissenborn/eventual2go"



type SentenceCompleter struct {
	*eventual2go.Completer
}

func NewSentenceCompleter() *SentenceCompleter {
	return &SentenceCompleter{eventual2go.NewCompleter()}
}

func (c *SentenceCompleter) Complete(d Sentence) {
	c.Completer.Complete(d)
}

func (c *SentenceCompleter) Future() *SentenceFuture {
	return &SentenceFuture{c.Completer.Future()}
}

type SentenceFuture struct {
	*eventual2go.Future
}

func (f *SentenceFuture) Result() Sentence {
	return f.Future.Result().(Sentence)
}

type SentenceCompletionHandler func(Sentence) Sentence

func (ch SentenceCompletionHandler) toCompletionHandler() eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		return ch(d.(Sentence))
	}
}

func (f *SentenceFuture) Then(ch SentenceCompletionHandler) *SentenceFuture {
	return &SentenceFuture{f.Future.Then(ch.toCompletionHandler())}
}

func (f *SentenceFuture) AsChan() chan Sentence {
	c := make(chan Sentence, 1)
	cmpl := func(d chan Sentence) SentenceCompletionHandler {
		return func(e Sentence) Sentence {
			d <- e
			close(d)
			return e
		}
	}
	ecmpl := func(d chan Sentence) eventual2go.ErrorHandler {
		return func(error) (eventual2go.Data, error) {
			close(d)
			return nil, nil
		}
	}
	f.Then(cmpl(c))
	f.Err(ecmpl(c))
	return c
}

type SentenceStreamController struct {
	*eventual2go.StreamController
}

func NewSentenceStreamController() *SentenceStreamController {
	return &SentenceStreamController{eventual2go.NewStreamController()}
}

func (sc *SentenceStreamController) Add(d Sentence) {
	sc.StreamController.Add(d)
}

func (sc *SentenceStreamController) Join(s *SentenceStream) {
	sc.StreamController.Join(s.Stream)
}

func (sc *SentenceStreamController) JoinFuture(f *SentenceFuture) {
	sc.StreamController.JoinFuture(f.Future)
}

func (sc *SentenceStreamController) Stream() *SentenceStream {
	return &SentenceStream{sc.StreamController.Stream()}
}

type SentenceStream struct {
	*eventual2go.Stream
}

type SentenceSubscriber func(Sentence)

func (l SentenceSubscriber) toSubscriber() eventual2go.Subscriber {
	return func(d eventual2go.Data) { l(d.(Sentence)) }
}

func (s *SentenceStream) Listen(ss SentenceSubscriber) *eventual2go.Completer {
	return s.Stream.Listen(ss.toSubscriber())
}

func (s *SentenceStream) ListenNonBlocking(ss SentenceSubscriber) *eventual2go.Completer {
	return s.Stream.ListenNonBlocking(ss.toSubscriber())
}

type SentenceFilter func(Sentence) bool

func (f SentenceFilter) toFilter() eventual2go.Filter {
	return func(d eventual2go.Data) bool { return f(d.(Sentence)) }
}

func toSentenceFilterArray(f ...SentenceFilter) (filter []eventual2go.Filter){

	filter = make([]eventual2go.Filter, len(f))
	for i, el := range f {
		filter[i] = el.toFilter()
	}
	return
}

func (s *SentenceStream) Where(f ...SentenceFilter) *SentenceStream {
	return &SentenceStream{s.Stream.Where(toSentenceFilterArray(f...)...)}
}

func (s *SentenceStream) WhereNot(f ...SentenceFilter) *SentenceStream {
	return &SentenceStream{s.Stream.WhereNot(toSentenceFilterArray(f...)...)}
}

func (s *SentenceStream) TransformWhere(t eventual2go.Transformer, f ...SentenceFilter) *eventual2go.Stream {
	return s.Stream.TransformWhere(t, toSentenceFilterArray(f...)...)
}

func (s *SentenceStream) Split(f SentenceFilter) (*SentenceStream, *SentenceStream)  {
	return s.Where(f), s.WhereNot(f)
}

func (s *SentenceStream) First() *SentenceFuture {
	return &SentenceFuture{s.Stream.First()}
}

func (s *SentenceStream) FirstWhere(f... SentenceFilter) *SentenceFuture {
	return &SentenceFuture{s.Stream.FirstWhere(toSentenceFilterArray(f...)...)}
}

func (s *SentenceStream) FirstWhereNot(f ...SentenceFilter) *SentenceFuture {
	return &SentenceFuture{s.Stream.FirstWhereNot(toSentenceFilterArray(f...)...)}
}

func (s *SentenceStream) AsChan() (c chan Sentence, stop *eventual2go.Completer) {
	c = make(chan Sentence)
	stop = s.Listen(pipeToSentenceChan(c))
	stop.Future().Then(closeSentenceChan(c))
	return
}

func pipeToSentenceChan(c chan Sentence) SentenceSubscriber {
	return func(d Sentence) {
		c <- d
	}
}

func closeSentenceChan(c chan Sentence) eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		close(c)
		return nil
	}
}

type SentenceCollector struct {
	*eventual2go.Collector
}

func NewSentenceCollector() *SentenceCollector {
	return &SentenceCollector{eventual2go.NewCollector()}
}

func (c *SentenceCollector) Add(d Sentence) {
	c.Collector.Add(d)
}

func (c *SentenceCollector) AddFuture(f *SentenceFuture) {
	c.Collector.Add(f.Future)
}

func (c *SentenceCollector) AddStream(s *SentenceStream) {
	c.Collector.AddStream(s.Stream)
}

func (c *SentenceCollector) Get() Sentence {
	return c.Collector.Get().(Sentence)
}

func (c *SentenceCollector) Preview() Sentence {
	return c.Collector.Preview().(Sentence)
}

type SentenceObservable struct {
	*eventual2go.Observable
}

func NewSentenceObservable (value Sentence) (o *SentenceObservable) {
	return &SentenceObservable{eventual2go.NewObservable(value)}
}

func (o *SentenceObservable) Value() Sentence {
	return o.Observable.Value().(Sentence)
}

func (o *SentenceObservable) Change(value Sentence) {
	o.Observable.Change(value)
}

func (o *SentenceObservable) OnChange(s SentenceSubscriber) (cancel *eventual2go.Completer) {
	return o.Observable.OnChange(s.toSubscriber())
}

func (o *SentenceObservable) Stream() (*SentenceStream) {
	return &SentenceStream{o.Observable.Stream()}
}


func (o *SentenceObservable) AsChan() (c chan Sentence, cancel *eventual2go.Completer) {
	return o.Stream().AsChan()
}

func (o *SentenceObservable) NextChange() (f *SentenceFuture) {
	return o.Stream().First()
}
