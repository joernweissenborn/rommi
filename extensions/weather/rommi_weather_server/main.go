package main

import (
	"bytes"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"rommi/brain/extension"
	"rommi/voice"
	"time"

	"github.com/ThingiverseIO/logger"
	"github.com/ThingiverseIO/thingiverseio"
	"github.com/joernweissenborn/eventual2go"
)

const descriptor = `
function TellCurrentWeather()()
property Forecast: JSON bin
`

const (
	cachefile      = "forecast_berlin.json"
	cacheValidTime = 30 * time.Minute
)

var log = logger.New("Rommi Weather Server")

type forecastProperty struct {
	JSON []byte
}

type checkCacheEvent struct{}
type tellCurWeatherEvent struct{}

type weatherServer struct {
	*eventual2go.Reactor
	cache   cacheFile
	forcast forecast
	output  *thingiverseio.Output
	voice   *voice.Voice
}

func (ws *weatherServer) openCache() (valid bool) {

	log.Initf("Looking for cache file at '%s'", cachefile)

	if ws.cache.exists() {
		log.Init("Cache file found")
		valid = ws.cache.valid()
		if valid {
			log.Init("Cache file is still valid")
		} else {
			log.Error("Cache file is not valid anymore")
		}
	} else {
		log.Init("Cache file not found")
	}
	return
}

func (ws *weatherServer) loadFromCache() (err error) {
	if err = ws.cache.open(); err != nil {
		log.Error("Error opening cache file ", err)
		return
	}
	defer ws.cache.Close()

	m, err := decodeJSON(ws.cache)
	if err != nil {
		log.Error("Error decoding cache file ", err)
		return
	}

	ws.forcast = forecastFromOpenWeatherMap(m)

	ws.updateForcastProperty()

	return
}

func (ws *weatherServer) update(eventual2go.Data) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	log.Init("loading from OWM")
	resp, err := http.Get("http://api.openweathermap.org/data/2.5/forecast?q=Berlin,de&APPID=6eb50c6619b7f0d0082c98bab93d97af")
	if err != nil {
		log.Error("Error getting OWM Data ", err)
		return
	}
	err = ws.cache.write(resp.Body)
	if err != nil {
		log.Error("Error getting OWM Data ", err)
		return
	}
	log.Info("Success")
	ws.loadFromCache()
}

func (ws *weatherServer) updateForcastProperty() {

	var buf bytes.Buffer
	ws.forcast.toJSON(&buf)
	ws.output.SetProperty("Forecast", forecastProperty{buf.Bytes()})
}
func (ws *weatherServer) tellCurWeather(d eventual2go.Data) {
	r := d.(*thingiverseio.Request)
	w := ws.forcast.current()
	speech := fmt.Sprintf("the weather is %s at %d degree", w.WeatherDesc, int(w.Temp-273.15))
	log.Info("Telling the weather: ", speech)
	ws.voice.Speak(speech)
	ws.output.Reply(r, nil)
}

func main() {
	log.Init("Starting up")

	output, err := thingiverseio.NewOutput(descriptor)
	if err != nil {
		log.Error("Error creating output: ", err)
		os.Exit(1)
		return
	}

	v, err := voice.New()
	if err != nil {
		log.Error("Error creating voice: ", err)
		os.Exit(1)
		return
	}
	v.Run()

	ws := &weatherServer{
		Reactor: eventual2go.NewReactor(),
		cache:   cacheFile{path: cachefile},
		output:  output,
		voice:   v,
	}

	if ws.openCache() {
		if ws.loadFromCache() != nil {
			ws.update(nil)
		}
	} else {
		ws.update(nil)
	}

	isTCW := func(r *thingiverseio.Request) bool { return r.Function == "TellCurrentWeather" }
	ws.React(tellCurWeatherEvent{}, ws.tellCurWeather)
	ws.AddStream(tellCurWeatherEvent{}, output.Requests().Where(isTCW).Stream)

	ws.React(checkCacheEvent{}, ws.update)
	ws.FireEvery(checkCacheEvent{}, nil, cacheValidTime)

	output.Run()

	extension.New(ext)

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	<-c
}
